// SPDX-License-Identifier: MPL-2.0

package provider

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/ctreminiom/go-atlassian/v2/pkg/infra/models"
	"github.com/ctreminiom/go-atlassian/v2/service/jira"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

var _ datasource.DataSource = (*workTypesDataSource)(nil)
var _ datasource.DataSourceWithConfigure = (*workTypesDataSource)(nil)

// NewWorkTypesDataSource returns the Terraform data source implementation for jira_work_types.
func NewWorkTypesDataSource() datasource.DataSource {
	return &workTypesDataSource{}
}

var emptyTypeModel = workTypeResourceModel{}

// When filtering by ids or names, Jira's /issuetype lacks server-side filtering and pagination.
// Emit a debug log when we must client-side filter a large set to aid troubleshooting.
const workTypesClientFilterThreshold = 100

type workTypesDataSource struct {
	ServiceClient
	typeService jira.TypeConnector
}

type workTypesDataSourceModel struct {
	Ids       types.List `tfsdk:"ids"`
	Names     types.List `tfsdk:"names"`
	WorkTypes types.Map  `tfsdk:"work_types"`
}

func (d *workTypesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_work_types"
}

func (d *workTypesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Use this data source to retrieve a list of work types from Jira.",
		Attributes: map[string]schema.Attribute{
			"ids": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "The Ids of the work type to search. If not provided, all work types will be returned.",
				Validators: []validator.List{
					listvalidator.ConflictsWith(path.MatchRoot("names")),
					listvalidator.UniqueValues(),
					listvalidator.ValueStringsAre(stringvalidator.LengthAtLeast(1)),
				},
			},
			"names": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Description: "The name of the work type to search. If not provided, all work types will be returned.",
				Validators: []validator.List{
					listvalidator.ConflictsWith(path.MatchRoot("ids")),
					listvalidator.UniqueValues(),
					listvalidator.ValueStringsAre(stringvalidator.LengthAtLeast(1)),
				},
			},
			"work_types": schema.MapNestedAttribute{
				Computed:            true,
				MarkdownDescription: "Map of work types returned by the query, keyed by work type ID for stability across renames.",
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: "The unique identifier of the work type. Automatically generated by Jira when the work type is created.",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: "The display name of the work type. This appears in the issue creation dialog and issue views.",
						},
						"icon_url": schema.StringAttribute{
							MarkdownDescription: "The URL of the work type's icon.",
							Computed:            true,
						},
						"description": schema.StringAttribute{
							Computed:            true,
							MarkdownDescription: "A detailed description of the work type. This helps users understand the purpose and usage of this work type.",
						},
						"subtask": schema.BoolAttribute{
							Computed:            true,
							MarkdownDescription: "Indicates whether this work type is used for subtasks. When `true`, issues of this type can only be created as children of other issues.",
						},
						"avatar_id": schema.Int64Attribute{
							Computed:            true,
							MarkdownDescription: "The ID of the avatar for the work type.",
						},
						"hierarchy_level": schema.Int32Attribute{
							Computed:            true,
							MarkdownDescription: HierarchyDescription,
						},
					},
				},
			},
		},
	}
}

func (d *workTypesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	provider, ok := req.ProviderData.(*JiraProvider)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected JiraProvider, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = provider.client
	d.typeService = provider.client.Issue.Type
	d.providerTimeouts = provider.providerTimeouts
}

func (d *workTypesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	ctx, cancel := withTimeout(ctx, d.providerTimeouts.Read)
	defer cancel()
	var data workTypesDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Parse ids and names. Defer evaluation on unknowns to avoid plan-time noise.
	ids, deferIDs := getKnownStrings(ctx, data.Ids, "ids", &resp.Diagnostics)
	if resp.Diagnostics.HasError() || deferIDs {
		return
	}
	names, deferNames := getKnownStrings(ctx, data.Names, "names", &resp.Diagnostics)
	if resp.Diagnostics.HasError() || deferNames {
		return
	}

	action := "list work types"
	if len(ids) > 0 {
		action += fmt.Sprintf(" (filter=ids:%d)", len(ids))
	}
	if len(names) > 0 {
		action += fmt.Sprintf(" (filter=names:%d)", len(names))
	}

	// Jira /issuetype is not paginated and lacks server-side filtering.
	issueTypes, apiResp, err := d.typeService.Gets(ctx)
	if !EnsureSuccessOrDiagFromSchemeWithOptions(ctx, action, apiResp, err, &resp.Diagnostics, &EnsureSuccessOrDiagOptions{IncludeBodySnippet: true}) {
		return
	}

	// Client-side filtering threshold debug log to aid troubleshooting.
	if (len(ids) > 0 || len(names) > 0) && len(issueTypes) >= workTypesClientFilterThreshold {
		tflog.Debug(ctx, "Client-side filtering of work types due to Jira /issuetype limitations", map[string]interface{}{
			"total_fetched":      len(issueTypes),
			"ids_filter_count":   len(ids),
			"names_filter_count": len(names),
			"threshold":          workTypesClientFilterThreshold,
		})
	}

	// Build filters and track found for warning messages
	idFilter := map[string]struct{}{}
	for _, id := range uniqueStrings(ids) {
		idFilter[id] = struct{}{}
	}
	nameFilter := map[string]struct{}{}
	for _, n := range uniqueStrings(names) {
		nameFilter[strings.ToLower(n)] = struct{}{}
	}
	foundIDs := map[string]struct{}{}
	foundNames := map[string]struct{}{}

	// Use List runner for mapping
	list := func(ctx context.Context) ([]*models.IssueTypeScheme, diag.Diagnostics) {
		var diags diag.Diagnostics
		return issueTypes, diags
	}

	var runner CRUDRunner[workTypeResourceModel, *models.IssueTypePayloadScheme, *models.IssueTypeScheme]
	objMap, mapDiags := runner.DoListIssueTypes(ctx, ListHooks[*models.IssueTypeScheme, workTypeResourceModel]{
		List: list,
		Filter: func(ctx context.Context, it *models.IssueTypeScheme) bool {
			if len(idFilter) > 0 {
				if _, ok := idFilter[it.ID]; ok {
					foundIDs[it.ID] = struct{}{}
					return true
				}
				return false
			}
			if len(nameFilter) > 0 {
				ln := strings.ToLower(it.Name)
				if _, ok := nameFilter[ln]; ok {
					foundNames[ln] = struct{}{}
					return true
				}
				return false
			}
			return true
		},
		KeyOf: func(it *models.IssueTypeScheme) string {
			return it.ID
		},
		MapToOut: func(ctx context.Context, it *models.IssueTypeScheme) (workTypeResourceModel, diag.Diagnostics) {
			var diags diag.Diagnostics
			var m workTypeResourceModel
			diags.Append(mapWorkTypeSchemeToModel(ctx, it, &m)...)
			return m, diags
		},
		AttrTypes: emptyTypeModel.AttributeTypes,
	})
	if mapDiags.HasError() {
		resp.Diagnostics.Append(mapDiags...)
		return
	}

	// Missing warnings
	if len(idFilter) > 0 {
		var missing []string
		for id := range idFilter {
			if _, ok := foundIDs[id]; !ok {
				missing = append(missing, id)
			}
		}
		if len(missing) > 0 {
			sort.Strings(missing)
			resp.Diagnostics.AddWarning(
				"Some requested work type IDs were not found",
				fmt.Sprintf("The following IDs were not found in Jira: %v. They will be omitted from the result.", missing),
			)
		}
	}
	if len(nameFilter) > 0 {
		var missing []string
		for n := range nameFilter {
			if _, ok := foundNames[n]; !ok {
				missing = append(missing, n)
			}
		}
		if len(missing) > 0 {
			sort.Strings(missing)
			resp.Diagnostics.AddWarning(
				"Some requested work type names were not found",
				fmt.Sprintf("The following names were not found in Jira: %v. They will be omitted from the result.", missing),
			)
		}
	}

	var mDiag diag.Diagnostics
	data.WorkTypes, mDiag = types.MapValueFrom(ctx, types.ObjectType{AttrTypes: emptyTypeModel.AttributeTypes()}, objMap)
	if mDiag.HasError() {
		resp.Diagnostics.AddAttributeError(
			path.Root("work_types"),
			"Failed to build work_types",
			fmt.Sprintf("Could not encode %d work types into state. This may indicate a schema mismatch or unexpected nulls. See underlying diagnostics for details.", len(objMap)),
		)
		resp.Diagnostics.Append(mDiag...)
		return
	}

	if diags := resp.State.Set(ctx, &data); diags.HasError() {
		resp.Diagnostics.AddError(
			"Failed to set data source state",
			"An unexpected error occurred while writing computed data to Terraform state. See diagnostics for details.",
		)
		resp.Diagnostics.Append(diags...)
		return
	}
}
